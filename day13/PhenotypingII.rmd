---
title: "Exercise"
author: "Malachy Campbell"
date: "Feb. 20, 2018"
output:
  rmdformats::material:
    highlight: kate
    self_contained: no
---

```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

#Vitis dataset
Here, we will bridge the gap between "classical" ampelography (the classification of grapevines based on phenotypic characteristics) and "digital" ampelography. Pierre Galet devised a series of morphological descriptors that could be used to differentiate between wine grape cultivars in the early 1960's. His efforts transformed ampelography from an art form to a science. However, imaging can be used to increase the throughput and accuracy of ampelography. This dataset was generated by Chitwood et al (2014). I encourage you to check out the paper, as it is an interesting read and combines imaging, genomics, and transcriptomics. The objective of their study was to provide a morphometric analysis of leaf shape for more than 1,200 grape accessions, and provide a genetic basis for these complex traits. The authors used photographs of leaves for a panel of 1,200 grape varieties at the USDA National Clonal Germplasm Repository. The authors used several metrics to describe the leaf shape (circularity, aspect ratio) and used the principle components from generalized Procrustes analysis (GPA) and Elliptical Fourier descriptors. In this dataset you'll find the digital descriptors, as well as those used by Galet (obtained from the USDA GRIN database).

[Chitwood et al (2012)](http://www.plantphysiol.org/content/164/1/259#def-3)

```{r table of traits}
#install.packages("knitr")
library(knitr)
DESC=data.frame(`Source of Trait`= c("Chitwood et al (2014)", "", "", "", "", "", "", "", "", "", "", "", "", "Galet (1952)", "", "", "", "", "", "", "", "", ""),
                `Column Name`=c("circ", "ar", "iPC1", "iPC2", "iPC3", "oPC1", "oPC2", "oPC3", "symPC1", "symPC2", "symPC3", "symPC4", "symPC5", "A", "B", "C", "r", "Spri", "S", "lowSup", "lowInf", "highSup", "highInf"),
                `Trait Name`=c("Circularity", "Aspect Ratio", "Inner PC1", "Inner PC2", "Inner PC3", "Outer PC1", "Outer PC2", "Outer PC3", "Symmetric PC1", "Symmetric PC2", "Symmetric PC3", "Symmetric PC4", "Symmetric PC5", "A", "B", "C", "r", "S'", "S", "SI2/L2", "SI1/L3", "SI2/L2", "SI1/L3"),
                `Description`=c("Ratio of the area to perimeter of an outline", "Ratio of the major axis to the minor axis of a fitted ellipse", "See figure 3B of Chitwood et al", "See figure 3B of Chitwood et al", "See figure 3B of Chitwood et al", "See figure 3A of Chitwood et al", "See figure 3A of Chitwood et al", "See figure 3A of Chitwood et al", "See figure 2 of Chitwood et al", "See figure 2 of Chitwood et al", "See figure 2 of Chitwood et al", "See figure 2 of Chitwood et al", "See figure 2 of Chitwood et al", "Ratio of the length of superior lateral vein to midrib", "Ratio of the length of inferior lateral vein to midrib", "Ratio of the length of petiolar vein to midrib", "Ratio of the length to width of the leaf", "Angle between midrib and inferior lateral vein", "Angle between midrib and petiolar vein", "low estimate of superior lobing", "low estimate of inferior lobing", "high estimate of superior lobing", "low inferior of superior lobing"))

kable(DESC, caption="Description of columns in Vitis dataset", col.names = c("Source of Trait", "Column Name", "Trait Name", "Description"))
```

##Phenotype Data
Here we'll load the phenotype data, and take a look at the first six lines. Each row corresponds to a grapevine accession from the USDA germplasm repository. Although 1200 accesssions were phenotyped by Chitwood et al (2012), only 122 had descriptions using Galet's method. The first 13 columns are the digital traits, and the last 10 are the classical measurements.
```{r load phenotype data, echo = T}
chitwood=read.csv("Phenotypes/Chitwood_Galet.csv", row.names=1)

#head(chitwood)
```

##Spearman correlation between digital and classical ampelography metrics
Here, we'll look at the correlation between digital and classical amelography measurements using Spearman's Rank correlation. 
```{r spearman correlation, echo = T}
sp.cor=cor(chitwood[1:13], chitwood[14:23], method = "spearman")
```

##Plot the results
Now, we'll plot the results as a nice heatmap.
```{r hm plot, echo = T}
#install.packages(gplots)
library(gplots)
heatmap.2(sp.cor, 
          Rowv=F, 
          Colv = F, 
          dendrogram = 'none', 
          trace='none', 
          cellnote=round(sp.cor, 2), 
          notecol="black",
          notecex = 0.5, 
          breaks=seq(-1, 1, length.out = 100),
          margins=c(6,6))
```

#Hyperspectral imaging for assessing drought responses in maize
The purpose of this exercise is to explore some hyperspectral imaging data, and determine which spectral bands and/or indicies can be used to predict plant water status. Here, we will look at some hyperspectral data collected from some corn plants under control and drought conditions. The plants were imaged over a period of 22 days during the V5 (5 leaf) to V6 (6 leaf) stage at UNL's Innovation Campus greenhouse. See [the Corny News Network](https://www.agry.purdue.edu/ext/corn/news/timeless/vstagemethods.html) for a description of the growth stages of corn. All plants were watered to 80% feild capacity prior to imaging, and a subset of plants were allowed to dry-down to 50% feild capacity throughout the imaging period. On the last total plant water content was measured for X plants (credit: Sajag Adhikari).

The goal of the exercise is to find the "best" index or hyperspectral band(s) for predicting plant water status. Feel free to try out some other published indicies or some alternative analyses [José R. Rodríguez-Pérez et al (2007) provides an extensive list](http://www.ajevonline.org/content/ajev/58/3/302.full.pdf). Below, you will find a few functions to calculate indices commonly used in hyperspectral studies. I will provide a brief example of how to calculate NDVI for each plant ($NDVI = \frac{R_{800} - R_{640}}{R_{800} + R_{640}}$) You can modify the code to use your own indices.

##Hyperspectral data
The imaging system provides a stack of 235 greyscale images for each plant. Each image in the stack is a specific wavelength. For each image, we remove the background objects leaving just the "plant pixels". Each plant pixel will be a single chandanel and the intensity of the channel should be proportional to the reflectance. So, a higher intensity means more reflectance for a given wavelength. For each image we obtain the mean pixel intensity (sum the pixel intensities and divide by the total number of plant pixels). This is equivalent to the mean reflectance for each plant. Here, we will read in the file of the mean pixel intensities for each plant.

```{r load data, echo = T}
dat=read.csv("Phenotypes/Hyperspec_pixel_density.csv")

#Check the first 10 columns of the phenotypic data
#head(dat[1:10])

#Plot the refectance for all wavelengths
dat.means=apply(dat[4:ncol(dat)], 2, mean)
plot(seq(from = 585, to = 1755, by=5), dat.means, type = "l", ylab="Reflectance", xlab="Wavelength")
```

```{r define hyperspec indices}
WI <- function(x){ x$bw_900/x$bw_970}

NDVI <- function(x){ (x$bw_800 - x$bw_640) / (x$bw_800 + x$bw_640)}

MSI <- function(x){ x$bw_1650 / x$bw_835}

MSI1 <- function(x){ x$bw_870 / x$bw_1350}

NDW <- function(x) { (x$bw_860 - x$bw_1240) / (x$bw_860 + x$bw_1240)}
```

Here, I will calculate the normalized difference vegetation index (NDVI). I will create a new dataframe named 'NDVI' that has the NDVI calculations, the plant ID, the treatment, and the day of imaging. I'll create a plot of NDVI over the six time points (1 - 22 days of imaging).
```{r NDVI, echo = T}
#Make the data frame
NDVI.df = data.frame(ID = dat$ID, Treatment = dat$Treatment, DayOfImaging = dat$DayOfImaging, NDVI = NDVI(dat))

#boxplot(NDVI~Treatment, data=NDVI.df, ylab="NDVI")

#Plot results
#install.packages("ggplot2")
library(ggplot2)

ggplot(NDVI.df, aes(x=DayOfImaging, y=NDVI, colour=Treatment)) + geom_smooth(method="loess") + xlab("Day of Imaging") + ylab("NDVI")
```

The indices defined above only capture a small portion of the total phenotype described by the hyperspectral data. Here, we will first utilize the whole hyperspectral range to predict plant water content. This data was collected at 24 days after imaging. For this part of the excersize we will utilize partial least squares regression in the package 'pls'. Below I will provide a brief explaination of the methodology. For those interested, the 'pls' manual provides an in-depth explaination of the PLSR technique, and a few example datasets [PLS](https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf). 

```{r partial least squares, echo = T}
#install.packages("pls")
library(pls)
#This dataset contains the reflacance values for all the wavelengths. These will be used as predictors for the percent of total biomass that is water ('Percent.Water'). 
dat2=read.csv("Phenotypes/Hyperspec_PWC.csv")
dat2$ID=NULL
dat2$Treatment=NULL
dat2$TotalWater=NULL
#Make a training set and validation set to assess the prediction accuracy
#This is similar to what we did for genomic prediction, however here we will only sample the data once.
traindat<-dat2[1:50,]
testdat<-dat2[51:87,]
```

```{r fit the plsr model, echo = T}
#Now we'll fit the PLSR model. We're regressing the Percent water on the hyperspectral data (Percent.Water ~ a).
full.spec <- plsr(Percent.Water ~., data = traindat)
summary(full.spec)
plot(RMSEP(full.spec), legendpos = "topright")
```

```{r plot fit, echo = T}
#This line shows the how well the model fits our data 
plot(full.spec, ncomp = 20, asp = 1, line = TRUE)
```

```{r predict for testing data, echo = T}
#Now we predict the percent water for the testing dataset using the model fit using the training dataset
Y.tst=predict(full.spec, ncomp = 20, newdata = testdat)
```


##Plot the results
```{r plot predicted, echo = T}
plot(Y.tst, testdat$Percent.Water, xlab= "Percent Water Predicted", ylab="Percent Water Observed")
abline(0,1, col="red")
```

##Calculate the correlation between predicted values and observed values in the data set
```{r calc correlation, echo = T}
cor(Y.tst, testdat$Percent.Water)
```



```{r plsr subset, echo = T}
sub.hyperspec <- function(startBW, endBW){
  if(sum(colnames(dat2) == paste0("bw_", startBW)) > 0){
    start.col=which(colnames(dat2) == paste0("bw_", startBW) )
  }else{
    print("Column name for first bandwidth does not exist")
  }
  if(sum(colnames(dat2) == paste0("bw_", endBW)) > 0){
    end.col=which(colnames(dat2) == paste0("bw_", endBW) )
  }else{
    print("Column name for last bandwidth does not exist")
  }
  tmp.df=as.data.frame(cbind(dat2$Percent.Water, dat2[, start.col:end.col]))
  colnames(tmp.df)[1]="Percent.Water"
  return(tmp.df)
}

dat3= sub.hyperspec(585, 605)

traindat2<-dat3[1:50,]
testdat2<-dat3[51:87,]
```

```{r fit2, echo = T}
#Now we'll fit the PLSR model. We're regressing the Percent water on the hyperspectral data (Percent.Water ~ a).
full.spec <- plsr(Percent.Water ~., data = traindat2)
summary(full.spec)
plot(RMSEP(full.spec), legendpos = "topright")
```

```{r plot fit2, echo = T}
plot(full.spec, asp = 1, line = TRUE)
```

```{r plot predicted 2, echo = T}
plot(Y.tst, testdat$Percent.Water, xlab= "Percent Water Predicted", ylab="Percent Water Observed")
abline(0,1, col="red")
```

##Calculate the correlation between predicted values and observed values in the data set
```{r calc correlation 2, echo = T}
cor(Y.tst, testdat$Percent.Water)
```